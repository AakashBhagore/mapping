{\rtf1\ansi\ansicpg1252\deff0\nouicompat\deflang1033{\fonttbl{\f0\fnil\fcharset0 Calibri;}{\f1\fnil Consolas;}{\f2\fnil\fcharset0 Consolas;}}
{\colortbl ;\red255\green0\blue0;\red0\green0\blue255;\red0\green77\blue187;\red0\green0\blue0;\red100\green100\blue100;\red232\green242\blue254;\red0\green0\blue192;}
{\*\generator Riched20 10.0.19041}\viewkind4\uc1 
\pard\sa200\sl276\slmult1\f0\fs22\lang9                                       \ul\b\fs44 Persistence with  Spring \line\line\ulnone\b0\fs28 To enable JPA in spring-boot-application we nedd to add spring-boot-starter and spring-boot-stater-data-jpa dependencies in pom.xml file.\line\line\cf1 Also in Spring Boot 1, the default connection pool was Tomcat, but with  Spring Boot 2 it has been changed to HikariCP|||\cf0\fs22\line {{\field{\*\fldinst{HYPERLINK https://www.netsurfingzone.com/spring/transactional-readonly-true-example-in-spring-boot/ }}{\fldrslt{https://www.netsurfingzone.com/spring/transactional-readonly-true-example-in-spring-boot/\ul0\cf0}}}}\f0\fs22\line\b\fs28 @Transactional:- \b0\fs24 Transactional Annotation is use when you want certain method to be executed inside the transaction. Or When we want to perform a rollback operation over a method.\line example: Let's assume user A wants to transfer 100$ to user B. What happens is:\par
We decrease A's account by 100$.    We add 100$ to B's account\par
Let's assume the exception is thrown after succeeding 1) and before executing 2). Now we would have some kind of inconsistency because A lost 100$ while B got nothing. Transactions means all or nothing. If there is an exception thrown somewhere in the method, changes are not persisted in the database. Something called rollback happens.\b\line\fs22\line\fs28 @Transactional( propagation = Propagation.SUPPORTS,readOnly = true ) :- \b0  \fs24 We can't be sure that insert and update won't be occur when the readOnly flag is set. \par
It's also improtant to uderstand  that readOnly flag is only relavant to within the transaction only.\line Rollback happend at runtime only, when transactional throw runtime exeception only. Checked exception does not trigger rollback of the transactional.  \par
\fs22\line\b\fs28 Importance of readOnly is that:-  \b0\fs24 If we use @Transactional(readOnly = true) to a method which is performing create or update operation then we will not have newly created or updated record into the database but we will have and use all the data as a response data. (The newly created and update data doesn't effect the data of database. But we will have the response data.)\par
\line i) \b create and update operation doesn't make in changes in the data of db. it will only make changes for response data. \line i\b0 i) readOnly is only relavante inside transcation. \line iii) By default @Transcational readOnly value is false. \line vi)Generally we can use readOnly for search or retrieval operation so that we can make sure we only perform read only operation. \b\line\fs28 Note:- \fs24 we are using @Transactional(readOnly = true), means we can perform the read-only operation, we can\rquote t perform save and any other operation in DB.\fs22\line\line\line                                                        \fs28   What Is Cascading?\line\b0 WWW(When we want) to perform some action on targeted entity, the same action will be performed on the assosiated entity. \line Or\par
 If we perform some action on parent entity same action will be performed on the child entity.\par
Or \line To establish the dependencies between the entities .\line\line All the Cascade operations are represented by the java.persistence.CascadeType.\line i) ALL   ii) PERSIST   ii) MERGE  iii) REMOVE   iv)REFRESH   v) DETACH\line\line Along with this hibernate support the follwing operation \line i)REPLICATE         ii)SAVE_UPDATE                iii)LOCK\line\line\b i) CascadeType.ALL \b0 :- will perform all the operation along with the hibernate given operations. from parent to child entity\line\line Question :- Without cascadeType is there is any we can save data in multiple table while following IS-A relationship. \line Answer:-  NO\line i\b i) CascadeType.PERSIST:-\b0  it means we can save data from parent-childs. if parent entity data saves also childs entity data saves.\line\line iii)\b CascadeType.MERGE:- \b0 When we perform any updation in both parent and child entities then we can use merge.\line\line iv) \b CascadeType.REMOVE:-\b0   as name suggest remove operation is used to remove data from the parent table(entity) as well as from the child table(Entity). There is no such difference between the CascadeType.REMOVE and \b CascadeType.DELETE\b0 . \line\line v) \b CascadeType.DETACH\b0\par
The detach operation removes the entity from the persistent context. When we use CascadeType.DETACH, \cf3 the child entity will also get removed from the persistent context.\cf0\line\line vi)  \b CascadeType.LOCK(CascadeType.REATTACH)\b0\par
Unintuitively, CascadeType.LOCK reattaches the entity and its associated child entity with the persistent context again.\line\line vii) \b CascadeType.REFRESH\b0\par
Refresh operations rere\tab ad the value of a given instance from the database. In some cases, we may change an instance after persisting in the database, but later we need to undo those changes.\par
In that kind of scenario, this may be useful. When we use this operation with Cascade Type REFRESH, the child entity also gets reloaded from the database whenever the parent entity is refreshed.\line\line viii) \b CascadeType.SAVE_UPDATE:- \b0 CascadeType.SAVE_UPDATE propagates the same operation to the associated child entity. It's useful when we use Hibernate-specific operations like save, update and saveOrUpdate. \line\line\cf1 Question:- what if use @Column attotation with @ManyToOne instide of @JoinColumn:\line Anaswer:- it will throw an exception ,  \cf4\f1\fs24 Caused by: org.hibernate.AnnotationException: @Column(s) not allowed on a @ManyToOne property: com.hibernate.jpa.model.Developer.manager\cf0\par
\f0\fs28\line\b @JoinColumn:- \b0 it works as a aliases. We can give the name of the column in child class.\line\line @\b JsonIgnore :- \b0 We will use this annotation www(when we want) a response in json format if response not given properly.\line\line\cf5\highlight6\f1\fs24 @ManyToOne\cf4 (fetch = FetchType.\cf7\b\i LAZY\cf4\b0\i0\f2\lang1033 :-\line\cf5\f1 @ManyToOne\cf4 (fetch = FetchType.\cf7\b\i\f2 EAGRLY\cf4\b0\i0\f1 )\f2 :-  \highlight0  It tell the hibernate to get all the elements of a relationships when selecting the root entity.\highlight6\line\line Entity mapping straegyies:\b\par
\highlight0\b0 The default configuration for entities mapping strategies is that for all the all-to-one we can use FetchType.EAGER, For all the ont-to-all default strategy is FetchType.LAZY\line\line FetchType:- there are manly two types of data loading.\line 1) Lazy :- In Lazy loading data load when we explicitly call it's                                                                                                                                                                                                                                                                                        getter or size(). it's a default loading for the one-to-all mapping. If we wanna fetch root entity elements only.\line\line 2) EAGER:- In eager loading the data load on the spot. \line            It's the default loading for the all-to-one mapping.\par
WWW to fetch the root entity as well as assosiated entity elements.\cf0\b\f0\fs28\lang9\line\par
WHENEVER GET THIS ERROR USE  BELOW ANNOTATION\par
\cf4\f1\fs24 Could not write JSON: \b0 failed to lazily initialize a collection of role: com.hibernate.jpa.model.Manager.lead, \b could not initialize proxy - no Session; nested exception is com\b0 .fasterxml.jackson.databind.JsonMappingException: failed to lazily initialize a collection of role: com.hibernate.jpa.model.Manager.lead, \b could not initialize proxy - no \b0 Session (through reference chain: com.hibernate.jpa.dto.Response["managers"]->java.util.ArrayList[0]->com.hibernate.jpa.model.Manager["lead"])]\cf0\par
\b\f0\fs28 answer:-     \cf5\highlight6\b0\f1\fs24 @JsonManagedReference\highlight0\f2\lang1033  (apply on root entity, when we don't want to fetch assosiate entities )\line\b\line\fs28 Question/Exception:-\fs24  Hibernate throws MultipleBagFetchException - cannot simultaneously fetch multiple bags\line Anaswer:-  There are two way we can solve this \line {{\field{\*\fldinst{HYPERLINK https://hibernate.atlassian.net/browse/HHH-1718 }}{\fldrslt{https://hibernate.atlassian.net/browse/HHH-1718\ul0\cf0}}}}\f2\fs24\par
i) While fetching data from multiple assosiate entities and if we're using fetchType.EAGER for both we should use Set instide of List<Developer> or List<LLead>. \par
\line ii) \highlight6\b0\f1 @Fetch\cf4 (value = FetchMode.\cf7\b\i SUBSELECT\cf4\b0\i0 )\line\line\cf0\highlight0\b\f0\fs28\lang9\line                                                      Mapping Directions\line\line Unidirectional:- \b0 unidirectional means in one direction. Mapping from root entity only.\line\b Example:- \b0 whenever data is not limited. we can use unidirectional is beacuse suppose we have one book and it's pages. when we fetch the details of books it's pages also loaded even though we don't need them.\line\line\b Bidirectional:- \b0 bidirectional means in both the direction. Mapping from root to relatated child entities.\line example:- whenever data is limited means while fetching the root element we can fetch assosiate entities element also then we can use bidirectional mapping. \line we need to do mapping in both the entity root as well as assosiate child entities.\line\line\line                                                \b HQL\line\b0 hql is stand for Hibernate Query Language. It the same as SQL but the only difference is that we can use entity class field name to prepare our query. that why is called as db independent language.\line\line\b Persistence:- \b0 An object is called persistence if it is store in the database and can be fetch any time.\fs22\par
}
 